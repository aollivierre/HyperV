# VMInformation.psm1
# Provides VM information and discovery functions

function Get-VMConfiguration {
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$ConfigPath = "D:\VM\Configs",

        [Parameter()]
        [ValidateSet('VSCode', 'Notepad', 'None')]
        [string]$Editor = 'VSCode'
    )

    Begin {
        Write-EnhancedLog -Message "Starting configuration file selection process" -Level "INFO"
        
        # Get all PSD1 files
        $getPSD1Params = @{
            Path = $ConfigPath
            Filter = "*.psd1"
            ErrorAction = 'SilentlyContinue'
        }
        
        $configFiles = Get-ChildItem @getPSD1Params
        
        if ($configFiles.Count -eq 0) {
            Write-EnhancedLog -Message "No configuration files found in $ConfigPath" -Level "ERROR"
            return $null
        }
    }

    Process {
        try {
            # Display available configurations
            Write-Host "`n=== Available VM Configurations ===" -ForegroundColor Cyan
            Write-Host "----------------------------------------" -ForegroundColor Cyan
            
            $configFiles | ForEach-Object -Begin { $index = 1 } -Process {
                Write-Host ("{0,3}. {1}" -f $index++, $_.BaseName)
            }
            Write-Host "----------------------------------------" -ForegroundColor Cyan

            # Get and validate user selection
            do {
                $selection = Read-Host "`nSelect a configuration (1-$($configFiles.Count))"
                $validSelection = $selection -match "^[1-$($configFiles.Count)]$"
                
                if (-not $validSelection) {
                    Write-Host "Invalid selection. Please enter a number between 1 and $($configFiles.Count)" -ForegroundColor Yellow
                }
            } while (-not $validSelection)

            # Load selected configuration
            $selectedConfig = $configFiles[$selection - 1]
            $configPath = $selectedConfig.FullName
            
            $importParams = @{
                Path = $configPath
                ErrorAction = 'Stop'
            }
            
            $config = Import-PowerShellDataFile @importParams

            # Display configuration details
            Write-Host "`nConfiguration Details:" -ForegroundColor Cyan
            Write-Host "----------------------------------------" -ForegroundColor Cyan
            $config.GetEnumerator() | Sort-Object Key | ForEach-Object {
                Write-Host ("{0,-20} = {1}" -f $_.Key, $_.Value)
            }
            Write-Host "----------------------------------------" -ForegroundColor Cyan

            # Confirm or edit configuration
            do {
                $proceed = Read-Host "`nProceed with this configuration? (Y)es, (E)dit, or (C)ancel"
                
                switch -Regex ($proceed) {
                    '^[Yy]$' {
                        Write-EnhancedLog -Message "Configuration selected: $($selectedConfig.Name)" -Level "INFO"
                        return $config
                    }
                    '^[Ee]$' {
                        Write-EnhancedLog -Message "Opening configuration for editing" -Level "INFO"
                        
                        switch ($Editor) {
                            'VSCode' { Start-Process code -ArgumentList $configPath -Wait }
                            'Notepad' { Start-Process notepad -ArgumentList $configPath -Wait }
                        }
                        
                        # Reload configuration after editing
                        $config = Import-PowerShellDataFile @importParams
                        
                        Write-Host "`nUpdated Configuration:" -ForegroundColor Cyan
                        $config.GetEnumerator() | Sort-Object Key | ForEach-Object {
                            Write-Host ("{0,-20} = {1}" -f $_.Key, $_.Value)
                        }
                    }
                    '^[Cc]$' {
                        Write-EnhancedLog -Message "Configuration selection cancelled" -Level "INFO"
                        return $null
                    }
                    default {
                        Write-Host "Invalid input. Please enter Y, E, or C" -ForegroundColor Yellow
                    }
                }
            } while ($proceed -notmatch '^[Yy]$|^[Cc]$')
        }
        catch {
            Write-EnhancedLog -Message "Error processing configuration: $($_.Exception.Message)" -Level "ERROR"
            Handle-Error -ErrorRecord $_
            return $null
        }
    }

    End {
        Write-EnhancedLog -Message "Configuration selection process completed" -Level "INFO"
    }
}

function Get-DependentVMs {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$VHDXPath
    )

    Begin {
        Write-EnhancedLog -Message "Starting Get-DependentVMs function" -Level "INFO"
        Log-Params -Params $PSCmdlet.MyInvocation.BoundParameters
    }

    Process {
        try {
            Write-EnhancedLog -Message "Retrieving all VMs" -Level "INFO"
            $allVMs = Get-VM
            Write-EnhancedLog -Message "Total VMs found: $($allVMs.Count)" -Level "INFO"

            $dependentVMs = [System.Collections.Generic.List[PSObject]]::new()

            foreach ($vm in $allVMs) {
                $hardDrives = $vm.HardDrives
                foreach ($hd in $hardDrives) {
                    try {
                        # Check if the VHD file exists before trying to access it
                        if (Test-Path $hd.Path) {
                            # Attempt to get the parent path of the VHD
                            $parentPath = (Get-VHD -Path $hd.Path).ParentPath

                            if ($parentPath -eq $VHDXPath) {
                                $dependentVMs.Add($vm)
                                Write-EnhancedLog -Message "Dependent VM: $($vm.Name)" -Level "INFO"
                                break
                            }
                        } else {
                            # Log a warning if the VHDX file does not exist
                            Write-EnhancedLog -Message "Warning: VHDX file not found: $($hd.Path). Skipping VM: $($vm.Name)" -Level "WARNING"
                        }
                    } catch {
                        # Log a warning if there was an error accessing the VHDX file
                        Write-EnhancedLog -Message "Warning: An error occurred while accessing VHDX file: $($hd.Path). Skipping VM: $($vm.Name)" -Level "WARNING"
                    }
                }
            }

            Write-EnhancedLog -Message "Total dependent VMs using VHDX $VHDXPath $($dependentVMs.Count)" -Level "INFO"
            return $dependentVMs
        } catch {
            Write-EnhancedLog -Message "An error occurred while retrieving dependent VMs: $($_.Exception.Message)" -Level "ERROR"
            Handle-Error -ErrorRecord $_
            return [System.Collections.Generic.List[PSObject]]::new()
        }
    }

    End {
        Write-EnhancedLog -Message "Exiting Get-DependentVMs function" -Level "INFO"
    }
}

function Get-NextVMNamePrefix {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$Config
    )

    Begin {
        Write-EnhancedLog -Message "Starting Get-NextVMNamePrefix function" -Level "INFO"
    }

    Process {
        try {
            Write-EnhancedLog -Message "Retrieving the most recent VM" -Level "INFO"
            $mostRecentVM = Get-VM | Sort-Object -Property CreationTime -Descending | Select-Object -First 1
            $prefixNumber = 0

            if ($null -ne $mostRecentVM) {
                Write-EnhancedLog -Message "Most recent VM found: $($mostRecentVM.Name)" -Level "INFO"
                if ($mostRecentVM.Name -match '^\d+') {
                    $prefixNumber = [int]$matches[0]
                    Write-EnhancedLog -Message "Extracted prefix number: $prefixNumber" -Level "INFO"
                } else {
                    Write-EnhancedLog -Message "Most recent VM name does not start with a number" -Level "INFO"
                }
            } else {
                Write-EnhancedLog -Message "No existing VMs found" -Level "INFO"
            }

            $nextPrefixNumber = $prefixNumber + 1
            $newVMNamePrefix = $Config.VMNamePrefixFormat -f $nextPrefixNumber
            Write-EnhancedLog -Message "Generated new VM name prefix: $newVMNamePrefix" -Level "INFO"

            return $newVMNamePrefix
        } catch {
            Write-EnhancedLog -Message "An error occurred in Get-NextVMNamePrefix: $($_.Exception.Message)" -Level "ERROR"
            Handle-Error -ErrorRecord $_
        }
    }

    End {
        Write-EnhancedLog -Message "Get-NextVMNamePrefix function completed" -Level "INFO"
    }
}

# Export all functions
Export-ModuleMember -Function @(
    'Get-VMConfiguration',
    'Get-DependentVMs',
    'Get-NextVMNamePrefix'
)